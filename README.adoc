= PHP-LRPM - PHP Long Running Process Manager

PHP-LRPM is a library for managing long running PHP processes.

image::https://raw.githubusercontent.com/vrza/php-lrpm/main/lrpmctl.png[lrpmctl screenshot]

== Motivation

Dynamic management of long running processes. Similar in function to process managers like daemontools or supervisord, but integrates with PHP code.

LRPM periodically reloads configuration from a custom source implemented in PHP (e.g. from a database), checks for changes in configuration and starts/stops processes accordingly.

This https://youtu.be/MJkFHMOCEkg[talk by Giorgio Sironi] given at the Dutch PHP Conference in 2017 covers some of the problems and challenges when implementing long running PHP processes.

== Features

=== Simple

PHP-LRPM is built on top of POSIX process management facilities. PHP-LRPM starts its subprocesses via `fork(2)` and subprocesses donâ€™t daemonize.

=== Efficient

The operating system signals PHP-LRPM immediately when a process terminates. PHP-LRPM will in turn attempt to restart the terminated process.

PHP-LRPM is able to take advantage of the OPcache PHP extension, allowing worker processes to store compiled bytecode in shared memory, which reduces the total memory usage of the process farm.

On Linux systems, PHP-LRPM is also able to take advantage of the fact that the `fork(2)` system call is implemented through the use of copy-on-write pages. This reduces the memory usage of Linux deployments even further.

=== Flexible

PHP-LRPM makes minimal assumptions about its use cases. It assumes no more than:

1. that worker processes will need to be provided with some sort of configuration
2. that they will need to run some code when they are started
3. that after initialization they might want to run in an endless loop.

PHP-LRPM uses exponential backoff when attempting to restart a process; some process managers will try several times in quick succession and fail the process until operator intervention.

== Non-goals

Currently LRPM is not intended to run as PID 1, nor was it tested in this role.

== Usage

1. Implement the `ConfigurationSource`. This interface exposes a public method `loadConfiguration()`, that returns an associative array containing the configuration for all the workers (see details below).
2. Implement the `Worker`. This interface exposes two public methods, `start()` and `cycle()`. The child process will call `start()`, passing the worker configuration as an argument, and then enter an endless loop, where it calls `cycle()`, and then checks for a shutdown condition (usually, the death of the LRPM supervisor process). Backoff should be implemented at the end of the cycle() method, as we dispatch signal handlers right after cycle() returns. Be careful not to run a tight loop at times when cycles are not doing actual work!

=== Job configuration

Configuration is a simple associative array of jobs to run. Here's an example configuration consisting of a single job, with all the mandatory fields described in comments:

[source,php]
----
$config = [
    42 => [ // Unique job id (string or int)
        'name' => 'Job 42', // Descriptive name (string)
        'workerClass' => '\PHPLRPM\Test\MockWorker', // Class implementing the Worker interface (string)
        'mtime' => 1629121362, // Time when this job config was last modified, as UTC Unix timestamp (int)
        'workerConfig' => [] // Array of additional configuration specific to the Worker implementation (array)
    ]
]
----

Class `ConfigurationValidator` is used for config validation internally, and you can also use it to test your `ConfigurationSource` implementation.

If a job's `mtime` returned by the `ConfigurationSource` is newer than `mtime` from previous poll, that job will be restarted with the new configuration.

See `example.php` for a full running example with more details.

==== Configuration fields

===== mtime

Time of last modification, must be a UTC Unix timestamp integer

Mandatory: yes

===== name

Descriptive job name, must be a string

Mandatory: yes

===== workerConfig

Worker-specific configuration, must be an array

Mandatory: yes

===== workerClass

Worker class, must be a string referencing an existing class

Mandatory: yes

===== shortRunTimeSeconds

Minimum number of seconds a process is expected to run; if the process terminates earlier then this, it will be restarted with backoff

Mandatory: no +
Default value: 5

===== shutdownTimeoutSeconds

Time in seconds to wait for SIGCHLD after sending SIGTERM to a child, before killing the child with SIGKILL

Mandatory: no +
Default value: 10


=== Signal handling

LRPM supervisor process installs signal handlers for SIGCHLD, SIGTERM and SIGINT.

You can implement and install your own signal handlers inside your Worker implementation, but make sure that your Worker process shuts down cleanly after receiving SIGTERM, otherwise LRPM will consider it unresponsive and follow up with a SIGKILL.

Default SIGTERM and SIGINT handlers will terminate the Worker before the next loop cycle.

=== Misc caveats

Be aware that code in your `ConfigurationSource` class will run in the supervisor (parent) process, while your `Worker` classes will run in child processes.

Sharing open sockets between parent and children through `fork(2)` is not safe. Worker processes should connect to wherever they need to connect to only after they have been spawned. For example, opening sockets in `ConfigurationSource`, in the parent process, passing them via references in the configuration associative array, and then using them in Worker processes is inherently unsafe.

== Operating LRPM

It is recommended to run LRPM as a normal system service. Its main process stays in the foreground and logs to stdout and stderr.

For LRPM to be able to listen for control messages, it needs to create a Unix domain socket in the `/run/php-lrpm` directory -- make sure that this directory is writable by the main LRPM process. As a fallback, LRPM will attempt to create a socket in `/run/user/<euid>/php-lrpm`. If a socket cannot be created, LRPM wil run with control messaging disabled.

Place the `bin/lrpmctl` tool into your PATH (either by adding `vendor/bin` to the PATH, or symlinking `lrpmctl` to e.g. `/usr/local/bin`) and use it to query the running instance for status, or to restart a process on demand. Type `lrpmctl -h` for more detailed usage instructions.

To take advantege of caching precompiled bytecode in shared memory, you need to explicitly enable using the OPcache extension in the CLI SAPI, and make sure that it's configured to store the cache in shared memory. Minimal recommended config is:

----
opcache.enable=1
opcache.enable_cli=1
opcache.file_cache_only=0
----

== Development roadmap

=== Completed

==== Improve metadata handling

PHP-LRPM keeps metadata in an associative array. For efficient lookups by PID, a separate index is maintained.

This functionality was offloaded to a generic library https://github.com/vrza/array-with-secondary-keys[Array with Secondary Keys], that wraps a hash map and maintains secondary indexes (similar to how secondary keys in an SQL database work). Implementing this particular collection lead to creation of https://github.com/vrza/cardinal-collections[Cardinal Collections], a PHP toolkit for building collections.

==== Implement receiving, handling and responding to control messages

Included is the `lrpmctl` tool, which uses the https://github.com/vrza/php-tipc[tipc] library to exchange messages with a running instance of LRPM. Some examples of messages include getting the `status` of running processes (see screenshot above), and requesting a `restart` of a process.

==== Make sure unresponsive processes get terminated

Wait for children to terminate after sending SIGTERM, follow up with SIGKILL if child doesn't respond to SIGTERM after some time.

==== Blocking shutdown

Implemented blocking shutdown loop that makes sure all children are terminated on shutdown, including processes that may be unresponsive.

== Some name ideas that were considered

* Palermo
* polearm
* poolroom

* pillar-pm
* polar-pm
* plural-pm
* plier-pm
