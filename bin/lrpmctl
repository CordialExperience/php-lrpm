#!/usr/bin/env php
<?php

declare(strict_types=1);
error_reporting(E_ALL);

const EXIT_SUCCESS = 0;
const EXIT_USAGE = 64;
const EXIT_AUTOLOADER_NOT_FOUND = 1;
const EXIT_NO_CONNECTION = 69;
const EXIT_INVALID_RESPONSE = 76;

// parse arguments
$shortopts = 'h';
$longopts = [
    'help',
    'color::'
];
$options = getopt($shortopts, $longopts, $rest_index);
$progname = basename($argv[0]);
$helpmsg = "Usage: $progname [<options>] <message>

Options:
  -h, --help         display this help and exit
  --color[=<when>]   use colored output (always/never/auto)

Send a 'help' message to a running lrpm instance to receive
helpful information about messages it can respond to.
";
if (array_key_exists('h', $options) || array_key_exists('help', $options)) {
    fwrite(STDERR, $helpmsg);
    exit(EXIT_USAGE);
}

$arg = $options['color'] ?? null;
if (!is_null($arg) && !in_array($arg, [false, 'auto', 'always', 'never'])) {
    fwrite(STDERR, $helpmsg);
    exit(EXIT_USAGE);
}
$color = $arg === 'always' || $arg === false ? true
       : ($arg === 'never' ? false
       : posix_isatty(STDOUT));

$rest = array_slice($argv, $rest_index);
if (count($rest) < 1) {
    fwrite(STDERR, $helpmsg);
    exit(EXIT_USAGE);
}
$request = implode(' ', $rest);
if (empty($request)) {
    exit(EXIT_SUCCESS);
}

probeForAutoloader($progname);

use TIPC\UnixSocketStreamClient;
use TextTableFormatter\Table;
use TerminalPalette\AnsiSeq;

$file = '/run/user/' . posix_geteuid() . '/php-lrpm/socket';
$client = new UnixSocketStreamClient($file);
if ($client->connect() === false) {
    exitNoConnection();
}
if ($client->sendMessage($request) === false) {
    exitNoConnection();
}
if (($response = $client->receiveMessage()) === false) {
    exitNoConnection();
}
$client->disconnect();

if ($response) handleResponse($request, $response, $color);


function probeForAutoloader($programName): void
{
    $autoload_locations = [
        __DIR__ . '/../vendor/autoload.php',
        __DIR__ . '/../../../autoload.php'
    ];

    foreach ($autoload_locations as $autoload_file) {
        if (file_exists($autoload_file)) {
            require_once($autoload_file);
            return;
        }
    }

    fwrite(STDERR, $programName . ': could not find autoload.php, use PHP Composer to generate autoloader code' . PHP_EOL);
    exit(EXIT_AUTOLOADER_NOT_FOUND);
}

function exitNoConnection(): void
{
    fwrite(STDERR, 'lrpm is not running' . PHP_EOL);
    exit(EXIT_NO_CONNECTION);
}

function handleResponse(string $msg, string $response, bool $color): void
{
    $args = explode(' ', $msg);
    if ($args[0] === 'status') {
        statusResponseHandler($response, $color);
    } else {
        genericResponseHandler($response);
    }
}

function genericResponseHandler(string $response): void
{
    fwrite(STDOUT, $response . PHP_EOL);
}

function statusResponseHandler(string $response, bool $color): void
{
    try {
        $status = parseStatus($response);
    } catch (Exception $e) {
        fwrite(STDERR, "Invalid response from lrpm daemon ({$e->getMessage()}): $response" . PHP_EOL);
        exit(EXIT_INVALID_RESPONSE);
    }
    $ps = ps(pidsFromStatus($status), ['rss']);
    fwrite(STDOUT, renderStatusTable($status, $ps, $color)->__toString());
}

/**
 * Parses and validates the LRPM status response
 *
 * @param string @jsonStatus
 * @return array
 * @throws Exception
 */
function parseStatus(string $jsonStatus): array
{
    $status = json_decode($jsonStatus, true);
    if (!is_array($status)) {
        throw new Exception('cannot parse as JSON');
    }
    foreach ($status as $metadata) {
        if (
            !array_key_exists('config', $metadata) ||
            !is_array($metadata['config']) ||
            !array_key_exists('name', $metadata['config']) ||
            !array_key_exists('state', $metadata) ||
            !is_array($metadata['state']) ||
            !array_key_exists('startedAt', $metadata['state'])
        ) {
            throw new Exception('missing fields');
        }
    }
    return $status;
}

function pidsFromStatus($status): array
{
    $pids = [];
    foreach ($status as $metadata) {
        if (isset($metadata['state']['pid']) && $metadata['state']['pid'] !== null) {
            $pids[] = $metadata['state']['pid'];
        }
    }
    return $pids;
}

function renderStatusTable(iterable $status, iterable $ps, bool $color): Table
{
    $header = [
        AnsiSeq::get('BOLD', $color) . 'ID'     . AnsiSeq::get('RESET', $color),
        AnsiSeq::get('BOLD', $color) . 'PID'    . AnsiSeq::get('RESET', $color),
        AnsiSeq::get('BOLD', $color) . 'RSS'    . AnsiSeq::get('RESET', $color),
        AnsiSeq::get('BOLD', $color) . 'UPTIME' . AnsiSeq::get('RESET', $color),
        AnsiSeq::get('BOLD', $color) . 'START'  . AnsiSeq::get('RESET', $color),
        AnsiSeq::get('BOLD', $color) . 'NAME'   . AnsiSeq::get('RESET', $color)
    ];
    $align = ['l', 'r', 'r', 'r', 'l', 'l'];
    $output = [$header];
    $redNone = AnsiSeq::get('RED', $color) . 'none' . AnsiSeq::get('RESET', $color);
    $redNotAvailable = AnsiSeq::get('RED', $color) . 'n/a' . AnsiSeq::get('RESET', $color);

    foreach ($status as $id => $metadata) {
        $config = $metadata['config'];
        $name = $config['name'];
        $state = $metadata['state'];
        $startedAt = $state['startedAt'];
        $pid = $state['pid'] ?? null;
        if ($pid !== null && isset($ps[$pid])) {
            $pidFmt = AnsiSeq::get('GREEN', $color) . $pid . AnsiSeq::get('RESET', $color);
            $rssFmt = $ps[$pid]['rss'];
            $startedAtDateTime = new DateTime();
            $startedAtDateTime->setTimestamp($startedAt);
            $uptime = $startedAtDateTime->diff(new DateTime('now'));
            $uptimeFmt = $uptime->format('%h:%I:%S');
            $startedAtFmt = date('Y-m-d H:i:s', $startedAt);
        } else {
            $pidFmt = $redNone;
            $rssFmt = $uptimeFmt = $startedAtFmt = $redNotAvailable;
            if (isset($state['restartAt']) && is_int($state['restartAt']) && $state['restartAt'] > 0) {
                $startedAtFmt = date('Y-m-d H:i:s', $state['restartAt']);
            }
        }
        $output[] = [$id, $pidFmt, $rssFmt, $uptimeFmt, $startedAtFmt, $name];
    }
    return (new Table($output))->setAlignment($align);
}

function ps(iterable $pids, iterable $format): array
{
    if (count($pids) === 0 || count($format) === 0) {
        return [];
    }
    $pidSsv = implode(' ', $pids);
    $fmtCsv = implode(',', $format);
    $cmd = "ps -o pid,$fmtCsv $pidSsv";
    exec($cmd, $output);
    array_shift($output);
    $processes = [];
    foreach ($output as $row) {
        $fields = explode(' ', preg_replace('/\s+/', ' ', trim($row)));
        $pid = array_shift($fields);
        for ($i = 0; $i < count($format); $i++) {
            $processes[$pid][$format[$i]] = $fields[$i];
        }
    }
    return $processes;
}
